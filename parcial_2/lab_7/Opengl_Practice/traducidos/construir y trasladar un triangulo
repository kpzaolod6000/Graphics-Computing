OBJETOS DE CONSTRUCCIÓN A PARTIR DE VERTICES
En última instancia, queremos dibujar más que un solo punto. Nos gustaría dibujar objetos construidos con muchos vértices. Se dedicarán grandes secciones de este libro a este tema. Por ahora, comenzamos con un ejemplo simple: definiremos tres vértices y los usaremos para dibujar un triángulo.
Podemos hacer esto haciendo dos pequeños cambios en el Programa 2.2 (en realidad, la versión en el Programa 2.4 que lee los sombreadores de los archivos): (a) modificar el sombreador de vértices para que tres vértices diferentes salgan a las etapas posteriores de la tubería, y (b) modificar la llamada glDrawArrays () para especificar que estamos usando tres vértices.
En la aplicación C ++ / OpenGL (específicamente en la llamada glDrawArrays ()) especificamos GL_TRIANGLES (en lugar de GL_POINTS), y también especificamos que hay tres vértices enviados a través de la canalización. Esto hace que el sombreador de vértices se ejecute tres veces y, en cada iteración, la variable incorporada gl_VertexID se incrementa automáticamente (inicialmente se establece en 0). Al probar el valor de gl_VertexID, el sombreador está diseñado para generar un punto diferente cada una de las tres veces que se ejecuta. Recuerde que los tres puntos luego pasan por la etapa de rasterización, produciendo un triángulo relleno. Las modificaciones se muestran en el Programa 2.5 (el resto del código es el mismo que se mostró anteriormente en el Programa 2.4).

ANIMANDO UNA ESCENA

Muchas de las técnicas de este libro se pueden animar. Esto es cuando las cosas en la escena se mueven o cambian, y la escena se renderiza repetidamente para reflejar estos cambios en tiempo real.
Recuerde de la Sección 2.1.1 que hemos construido nuestro main () para hacer una sola llamada a init (), y luego para llamar a display () repetidamente. Por lo tanto, si bien cada uno de los ejemplos anteriores puede parecer una única escena renderizada fija, en realidad el bucle principal estaba provocando que se dibujara una y otra vez.
Por esta razón, nuestro main () ya está estructurado para admitir animación. Simplemente diseñamos nuestra función display () para alterar lo que dibuja con el tiempo. Cada representación de nuestra escena se denomina fotograma, y ​​la frecuencia de las llamadas a display () es la velocidad de fotogramas. El manejo de la tasa de movimiento dentro de la lógica de la aplicación se puede controlar usando el tiempo transcurrido desde el cuadro anterior (esta es la razón para incluir “currentTime” como parámetro en la función display ()).
Se muestra un ejemplo en el Programa 2.6. Hemos tomado el triángulo del Programa 2.5 y lo hemos animado para que se mueva hacia la derecha, luego se mueva hacia la izquierda, adelante y atrás. En este ejemplo, no consideramos el tiempo transcurrido, por lo que el triángulo puede moverse más o menos rápidamente dependiendo de la velocidad de la computadora. En futuros ejemplos, usaremos el tiempo transcurrido para asegurarnos de que nuestras animaciones se ejecuten a la misma velocidad independientemente del equipo en el que se ejecuten.
En el Programa 2.6, el método display () de la aplicación mantiene una variable "x" utilizada para compensar la posición de la coordenada X del triángulo. Su valor cambia cada vez que se llama a display () (y por lo tanto es diferente para cada fotograma), e invierte la dirección cada vez que alcanza 1.0 o -1.0. El valor en x se copia a una variable correspondiente llamada "desplazamiento" en el sombreador de vértices. El mecanismo que realiza esta copia utiliza algo llamado variable uniforme, que estudiaremos más adelante en el Capítulo 4.
No es necesario comprender todavía los detalles de las variables uniformes. Por ahora, solo tenga en cuenta que la aplicación C ++ / OpenGL primero llama a glGetUniformLocation () para obtener un puntero a la variable "offset", y luego llama a glProgramUniform1f () para copiar el valor de x en offset. El sombreador de vértices luego agrega el desplazamiento a la coordenada X del triángulo que se está dibujando. Tenga en cuenta también que el fondo se borra en cada llamada a display (), para evitar que el triángulo deje un rastro a medida que se mueve. La Figura 2.16 ilustra la pantalla en tres instancias de tiempo (por supuesto, el movimiento no se puede mostrar en una figura fija).

 Tenga en cuenta que además de agregar código para animar el triángulo, también hemos agregado la siguiente línea al comienzo de la función display ():

glClear (GL_DEPTH_BUFFER_BIT);

Un triángulo animado y en movimiento. Si bien no es estrictamente necesario en este ejemplo en particular, lo hemos agregado aquí y seguirá apareciendo en la mayoría de nuestras aplicaciones. Recuerde de la discusión en la Sección 2.1.7 que la remoción de superficies ocultas requiere tanto un búfer de color como un búfer de profundidad. A medida que procedamos a dibujar escenas 3D progresivamente más complejas, será necesario inicializar (borrar) el búfer de profundidad de cada fotograma, especialmente para las escenas animadas, para garantizar que las comparaciones de profundidad no se vean afectadas por los datos de profundidad antiguos. Debería ser evidente a partir del ejemplo anterior que el comando para borrar el búfer de profundidad es esencialmente el mismo que para borrar el búfer de color.
