ORGANIZAR LOS ARCHIVOS DE CÓDIGO C ++

Hasta ahora, hemos estado colocando todo el código de la aplicación C ++ / OpenGL en un solo archivo llamado “main.cpp” y los sombreadores GLSL en archivos llamados “vertShader. glsl ”y“ fragShader.glsl ”. Si bien admitimos que introducir una gran cantidad de código de aplicación en main.cpp no ​​es una buena práctica, hemos adoptado esta convención en este libro para que quede absolutamente claro en cada ejemplo qué archivo contiene el bloque principal de código C ++ / OpenGL relevante al ejemplo que se está discutiendo. A lo largo de este libro de texto, siempre se llamará “main.cpp”. En la práctica, las aplicaciones deben, por supuesto, estar modularizadas para reflejar adecuadamente las tareas realizadas por la aplicación; sin embargo, a medida que avancemos, habrá circunstancias en las que creamos módulos que serán útiles en muchas aplicaciones diferentes. Siempre que sea apropiado, trasladaremos esos módulos a archivos separados para facilitar su reutilización. Por ejemplo, más adelante definiremos una clase Sphere que será útil en muchos ejemplos diferentes, por lo que se separará en sus propios archivos (Sphere.cpp y Sphere.h).
De manera similar, cuando encontremos funciones que deseamos reutilizar, las colocaremos en un archivo llamado “Utils.cpp” (y un “Utils.h” asociado). Ya hemos visto varias funciones que son apropiadas para pasar a “Utils.cpp”: los módulos de detección de errores descritos en la Sección 2.2 y las funciones para leer en los programas de sombreado GLSL descritas en la Sección 2.3. Este último es particularmente adecuado para la sobrecarga, de modo que se puede definir una función "createShaderProgram ()" para cada combinación posible de sombreadores de canalización ensamblados en una aplicación determinada:

• GLuint Utils :: createShaderProgram (const char * vp, const char * fp)
• GLuint Utils :: createShaderProgram (const char * vp, const char * gp, const char * fp)
• GLuint Utils :: createShaderProgram (const char * vp, const char * tCS, const char * tES, const char * fp)
• GLuint Utils :: createShaderProgram (const char * vp, const char * tCS, const char * tES, const char * gp, const char * fp)

El primer caso de la lista anterior admite programas de sombreado que utilizan solo un sombreador de vértices y fragmentos. El segundo es compatible con aquellos que utilizan sombreadores de vértices, geometría y fragmentos. El tercero admite aquellos que usan sombreadores de vértices, teselados y fragmentos. Y el cuarto admite aquellos que usan sombreadores de vértices, teselación, geometría y fragmentos. Los parámetros aceptados en cada caso son nombres de ruta para los archivos GLSL que contienen el código de sombreado. Por ejemplo, la siguiente llamada usa una de las funciones sobrecargadas para compilar y vincular un programa de canalización de sombreado que incluye un sombreador de vértices y fragmentos. El programa completo se coloca en la variable "renderingProgram": renderingProgram = Utils :: createShaderProgram ("vertShader.glsl", "fragShader.glsl");
Estas implementaciones de createShaderProgram () se pueden encontrar en el CD adjunto (en el archivo “Utils.cpp”), y todas incorporan los módulos de detección de errores de la Sección 2.2 también. No hay nada nuevo en ellos; simplemente están organizados de esta manera por conveniencia. A medida que avancemos en el libro, se agregarán otras funciones similares a Utils.cpp a medida que avancemos. Se recomienda encarecidamente al lector que examine el archivo Utils.cpp en el CD adjunto e incluso que lo agregue como desee. Los programas que se encuentran allí se construyen a partir de los métodos que aprendemos en el libro, y el estudio de su organización debería servir para fortalecer la propia comprensión.
Con respecto a las funciones en el archivo "Utils.cpp", las hemos implementado como métodos estáticos para que no sea necesario crear una instancia de la clase Utils. Los lectores pueden preferir implementarlos como métodos de instancia en lugar de métodos estáticos, o incluso como funciones independientes, dependiendo de la arquitectura del sistema particular que se esté desarrollando.
Todos nuestros sombreadores se nombrarán con una extensión ".glsl".
