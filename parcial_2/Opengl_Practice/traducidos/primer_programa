La mayor parte de nuestra aplicación de gráficos está escrita en C ++. Dependiendo del propósito del programa, puede interactuar con el usuario final utilizando bibliotecas estándar de C ++. Para las tareas relacionadas con el renderizado 3D, utiliza llamadas OpenGL. Como se describe en el capítulo anterior, utilizaremos varias bibliotecas adicionales: GLEW (OpenGL Extension Wrangler), GLM (OpenGL Mathematics), SOIL2 (SimpleOpenGL Image Loader) y GLFW (Graphics Library Framework).
La biblioteca GLFW incluye una clase llamada GLFWwindow en la que podemos dibujar escenas 3D. Como ya se mencionó, OpenGL también nos da comandos para instalar programas GLSL en las etapas de sombreado programables y compilarlos.
Finalmente, OpenGL usa búferes para enviar modelos 3D y otros datos gráficos relacionados en el proceso.
Antes de intentar escribir sombreadores, escribamos una aplicación C ++ / OpenGL simple que cree una instancia de una ventana GLFW y establezca su color de fondo. ¡Hacer eso no requerirá ningún sombreador en absoluto! El código se muestra en el Programa 2.1. La función main () que se muestra en el Programa 2.1 es la misma que usaremos a lo largo de este libro de texto.
Entre las operaciones significativas en main () están: (a) inicializa la biblioteca GLFW, (b) instancia una GLFWwindow, (c) inicializa la biblioteca GLEW, (d) llama a la función "init ()" una vez, y (e) llama a la función “display ()” repetidamente.
La función "init ()" es donde colocaremos las tareas de inicialización específicas de la aplicación. El método display () es donde colocamos el código que se dibuja en la ventana GLFW.

En este ejemplo, el comando glClearColor () especifica el valor de color que se aplicará al borrar el fondo, en este caso (1,0,0,1), correspondiente a los valores RGB del color rojo (más un "1" para el componente de opacidad). Luego usamos la llamada de OpenGL glClear (GL_COLOR_BUFFER_BIT) para llenar el búfer de color con ese color.

El mecanismo por el cual se implementan estas funciones es el siguiente: las bibliotecas GLFW y GLEW se inicializan usando los comandos glfwInit () y glewInit () respectivamente. La ventana GLFW y un contexto OpenGL asociado se crean con el comando glfwCreateWindow (), con opciones establecidas por cualquier sugerencia de ventana anterior. Nuestras sugerencias de ventana especifican que la máquina debe ser compatible con la versión 4.3 de OpenGL ("mayor" = 4. y "menor" = 3). Los parámetros del comando glfwCreateWindow () especifican el ancho y alto de la ventana (en píxeles) y el título colocado en la parte superior de la ventana. (Los dos parámetros adicionales que están configurados en NULL y que no estamos usando permiten el modo de pantalla completa y el uso compartido de recursos). La sincronización vertical (VSync) se habilita mediante los comandos glfwSwapInterval () y glfwSwapBuffers (): ventanas GLFW tienen por defecto doble búfer. 2 Tenga en cuenta que la creación de la ventana GLFW no convierte automáticamente el contexto OpenGL asociado en actual, por esa razón también llamamos glfwMakeContextCurrent ().

Nuestro main () incluye un ciclo de renderizado muy simple que llama a nuestra función display () repetidamente. También llama a glfwSwapBuffers (), que pinta la pantalla, y glfwPollEvents (), que maneja otros eventos relacionados con la ventana (como una tecla que se presiona). El ciclo termina cuando GLFW detecta un evento que debería cerrar la ventana (como cuando el usuario hace clic en la "X" en la esquina superior derecha). Tenga en cuenta que hemos incluido una referencia al objeto de ventana GLFW en las llamadas init () y display (); esas funciones pueden, en determinadas circunstancias, necesitar acceder a él. También hemos incluido la hora actual en la llamada a display (), que será útil para garantizar que nuestras animaciones se ejecuten a la misma velocidad independientemente de la computadora que se utilice. Para este propósito, usamos glfwGetTime (), que devuelve el tiempo transcurrido desde que se inicializó GLFW.

Ahora es un momento apropiado para observar más de cerca las llamadas OpenGL en el Programa 2.1. Considere este:

En este caso, la función OpenGL que se llama, como se describe en la documentación de referencia de OpenGL (disponible en la web en https://www.opengl.org/sdk/docs), es:

El parámetro hace referencia a un "GLbitfield" llamado "GL_COLOR_BUFFER_BIT". OpenGL tiene muchas constantes predefinidas (algunas de ellas se llaman enumeraciones); éste hace referencia al búfer de color que contiene los píxeles a medida que se representan. OpenGL tiene varios búferes de color y este comando los borra todos, es decir, los llena con un color predefinido llamado "color claro". Tenga en cuenta que "claro" en este contexto no significa "un color que es claro"; más bien, se refiere al color que se aplica cuando se restablece (borra) un búfer de color.
Inmediatamente antes de la llamada a glClear () hay una llamada a glClearColor (). Esto nos permite especificar el valor colocado en los elementos de un búfer de color cuando se borra. Aquí hemos especificado (1,0,0,1), que corresponde al color rojo RGBA.
Finalmente, nuestro ciclo de renderización sale cuando el usuario intenta cerrar la ventana GLFW. En ese momento, nuestro main () le pide a GLFW que destruya la ventana y termine, a través de llamadas a glfwDestroyWindow () y glfwTerminate () respectivamente.


