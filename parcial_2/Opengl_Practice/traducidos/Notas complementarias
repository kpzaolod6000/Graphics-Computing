NOTAS COMPLEMENTARIAS
Hay muchos detalles de la canalización de OpenGL que no hemos discutido en este capítulo introductorio. Hemos omitido una serie de etapas internas y hemos omitido por completo cómo se procesan las texturas. Nuestro objetivo era trazar, de la forma más sencilla posible, el marco en el que escribiremos nuestro código. A medida que avancemos, continuaremos aprendiendo detalles adicionales.
También hemos aplazado la presentación de ejemplos de código para teselación y geometría. En capítulos posteriores crearemos sistemas completos que muestran cómo escribir sombreadores prácticos para cada una de las etapas.
Hay formas más sofisticadas de organizar el código para animar una escena, especialmente con respecto a la gestión de subprocesos. Algunos enlaces de lenguaje como JOGL y LWJGL (para Java) ofrecen clases para admitir la animación. Se anima a los lectores interesados ​​en diseñar un bucle de renderizado (o “bucle de juego”) apropiado para una aplicación en particular a consultar algunos de los libros más especializados sobre diseño de motores de juegos (por ejemplo, [NY14]) y a leer detenidamente las discusiones relacionadas sobre gamedev. neto [GD17].
Pasamos por alto un detalle en el comando glShaderSource (). El cuarto parámetro se utiliza para especificar una "matriz de longitudes" que contiene las longitudes de cadenas enteras de cada línea de código en el programa de sombreado dado. Si este parámetro se establece en nulo, como hemos hecho, OpenGL construirá esta matriz automáticamente si las cadenas terminan en nulo. Si bien hemos tenido cuidado de asegurarnos de que nuestras cadenas enviadas a glShaderSource () terminen en nulo (llamando a la función c_str () en createShaderProgram ()), no es raro encontrar aplicaciones que construyan estas matrices manualmente en lugar de enviar nulos.
A lo largo de este libro, el lector a veces puede desear conocer uno o más de los límites superiores de OpenGL. Por ejemplo, es posible que el programador necesite conocer el número máximo de salidas que puede producir el sombreador de geometría o el tamaño máximo que se puede especificar para representar un punto. Muchos de estos valores dependen de la implementación, lo que significa que pueden variar entre diferentes máquinas. OpenGL proporciona un mecanismo para recuperar dichos límites usando el comando glGet (), que toma varias formas dependiendo del tipo de parámetro que se consulta. Por ejemplo, para encontrar el tamaño de punto máximo permitido, la siguiente llamada colocará los valores mínimo y máximo (para la implementación de OpenGL de su máquina) en los dos primeros elementos de la matriz flotante denominada "tamaño":

glGetFloatv (GL_POINT_SIZE_RANGE, tamaño)

Son posibles muchas de estas consultas. Consulte la documentación de referencia de OpenGL [OP16] para ver ejemplos.
En este capítulo, hemos intentado describir cada parámetro en cada llamada de OpenGL. Sin embargo, a medida que avanza el libro, esto se volverá difícil de manejar y, a veces, no nos molestaremos en describir un parámetro cuando creemos que hacerlo complicaría las cosas innecesariamente. Esto se debe a que muchas funciones de OpenGL tienen una gran cantidad de parámetros que son irrelevantes para nuestros ejemplos. El lector debe acostumbrarse a usar la documentación de OpenGL para completar dichos detalles cuando sea necesario.
