A continuación, display () habilita el búfer que contiene los vértices del cubo y lo adjunta al atributo de vértice 0 para preparar el envío de los vértices al sombreador.
Lo último que hace display () es dibujar el modelo llamando a glDrawArrays (), especificando que el modelo está compuesto por triángulos y tiene 36 vértices en total. La llamada a glDrawArrays () suele ir precedida de comandos adicionales que ajustan la configuración de renderizado para este modelo.4 En este ejemplo, hay dos comandos de este tipo, ambos relacionados con las pruebas de profundidad. Recuerde del Capítulo 2 que OpenGL utiliza las pruebas de profundidad para realizar la eliminación de superficies ocultas. Aquí, habilitamos las pruebas de profundidad y especificamos la prueba de profundidad particular que deseamos que use OpenGL. Los ajustes que se muestran aquí corresponden a la descripción del Capítulo 2; más adelante en el libro veremos otros usos para estos comandos.
Finalmente, considere los sombreadores. Primero, tenga en cuenta que ambos incluyen el mismo bloque de declaraciones de variables uniformes. Aunque esto no siempre es necesario, a menudo es una buena práctica incluir el mismo bloque de declaraciones de variables uniformes en todos los sombreadores dentro de un programa de renderizado particular.
Observe también en el sombreador de vértices la presencia del calificador de diseño en la posición del atributo de vértice entrante. Dado que la ubicación se especifica como "0", la función display () puede hacer referencia a esta variable simplemente usando 0 en el primer parámetro de la llamada a la función glVertexAttribPointer () y en la llamada a la función glEnableVertexAttribArray ().
Tenga en cuenta también que el atributo de vértice de posición se declara como vec3, por lo que debe convertirse en vec4 para que sea compatible con las matrices 4x4 con las que se multiplicará. Esta conversión se realiza con vec4 (posición, 1.0), que construye un vec4 a partir de la variable denominada "posición", poniendo un valor de 1.0 en el cuarto lugar recién agregado.
La multiplicación en el sombreador de vértices aplica las transformaciones matriciales al vértice, convirtiéndolo en espacio de cámara (observe el orden de concatenación de derecha a izquierda).
Esos valores se colocan en la variable de salida incorporada de OpenGL gl_Position, y luego continúan a través de la canalización y son interpolados por el rasterizador.
Las ubicaciones de píxeles interpoladas (denominadas fragmentos) se envían luego al sombreador de fragmentos. Recuerde que el propósito principal del sombreador de fragmentos es establecer el color de un píxel de salida. De manera similar al sombreador de vértices, el sombreador de fragmentos procesa los píxeles uno por uno, con una invocación separada para cada píxel. En este caso, genera un valor codificado correspondiente a rojo. Por las razones indicadas anteriormente, las variables uniformes se han incluido en el sombreador de fragmentos aunque no se estén utilizando allí en este ejemplo.
En la Figura 4.5 se muestra una descripción general del flujo de datos que comienza con la aplicación C ++ / OpenGL y pasa por la tubería.

4 A menudo, estas llamadas se pueden colocar en init () en lugar de en display (). Sin embargo, es necesario colocar uno o más de ellos en display () al dibujar múltiples objetos con diferentes propiedades. Por simplicidad, siempre los colocamos en display ().

Hagamos una pequeña modificación a los sombreadores. En particular, asignaremos un color a cada vértice de acuerdo con su ubicación, y colocaremos ese color en el atributo de vértice saliente varyingColor. El sombreador de fragmentos se revisa de manera similar para aceptar el color entrante (interpolado por el rasterizador) y usarlo para establecer el color del píxel de salida. Tenga en cuenta que el código también multiplica la ubicación por 1/2 y luego agrega 1/2 para convertir el rango de valores de [-1 .. + 1] a [0..1]. Tenga en cuenta también el uso de la convención común de asignar nombres de variables que incluyen la palabra "variable" a los atributos de vértice interpolados definidos por el programador. Los cambios en cada sombreador se resaltan y el resultado resultante es el siguiente

Tenga en cuenta que debido a que los colores se envían desde el sombreador de vértices en un atributo de vértice (varyingColor), ¡el rasterizador también los interpola! El efecto de esto se puede ver en la Figura 4.6, donde los colores de esquina a esquina están claramente interpolados suavemente en todo el cubo.
Tenga en cuenta también que la variable "out" varyingColor en el sombreador de vértices también es la variable "in" en el sombreador de fragmentos. Los dos sombreadores saben qué variable del sombreador de vértices alimenta qué variable en el sombreador de fragmentos porque tienen el mismo nombre "varyingColor" en ambos sombreadores.
Dado que nuestro main () incluye un bucle de renderizado, podemos animar nuestro cubo como hicimos en el Programa 2.6, construyendo la matriz del modelo usando una traslación y rotación variables basadas en el tiempo. Por ejemplo, el código en la función display () en el Programa 4.1 podría modificarse de la siguiente manera (los cambios están resaltados):