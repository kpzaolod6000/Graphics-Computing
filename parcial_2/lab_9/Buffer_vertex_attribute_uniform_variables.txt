La forma en que cargamos los vértices de un modelo en un búfer (VBO) depende de dónde se almacenan los valores de los vértices del modelo. En el Capítulo 6 veremos cómo los modelos se construyen comúnmente en una herramienta de modelado (como Blender [BL16] o Maya [MA16]), se exportan a un formato de archivo estándar (como .obj, también descrito en el Capítulo 6) y se importan. en la aplicación C ++ / OpenGL. También veremos cómo los vértices de un modelo se pueden calcular sobre la marcha o generar dentro de la tubería utilizando un sombreador de teselación.
Por ahora, digamos que deseamos dibujar un cubo, y supongamos que los vértices de nuestro cubo están codificados en una matriz en la aplicación C ++ / OpenGL. En ese caso, necesitamos copiar esos valores en uno de nuestros dos búferes que generamos previamente. Para hacer eso, necesitamos (a) hacer ese búfer (digamos, el búfer 0) "activo" con el comando OpenGL glBindBuffer (), y (b) usar el comando glBufferData () para copiar la matriz que contiene los vértices en el búfer activo (el 0º VBO en este caso). Suponiendo que los vértices se almacenan en una matriz flotante llamada vPositions, el siguiente código 2 de C ++ copiaría esos valores en el 0º VBO:
glBindBuffer (GL_ARRAY_BUFFER, vbo [0]);
glBufferData (GL_ARRAY_BUFFER, tamaño de (vPositions), vPositions, GL_STATIC_DRAW);
A continuación, agregamos código a display () que hará que los valores en el búfer se envíen al atributo de vértice en el sombreador. Hacemos esto con los siguientes tres pasos: (a) hacer que el búfer esté "activo" con el comando glBindBuffer () como hicimos anteriormente, (b) asociar el búfer activo con un atributo de vértice en el sombreador, y (c) habilitar el atributo de vértice. Las siguientes líneas de código cumplen estos pasos:
glBindBuffer (GL_ARRAY_BUFFER, vbo [0]); // hace que el búfer 0 sea "activo" glVertexAttribPointer (0, 3, GL_FLOAT, GL_FALSE, 0, 0); // asociar el atributo 0 con el búfer glEnableVertexAttribArray (0); // habilita el atributo del vértice 0
Ahora, cuando ejecutamos glDrawArrays (), los datos en el 0º VBO se transmitirán al atributo de vértice que tiene un calificador de diseño con ubicación 0. Esto envía los vértices del cubo al sombreador. 2 Tenga en cuenta que aquí, por primera vez, nos abstenemos de describir cada parámetro en una o más llamadas OpenGL. Como se mencionó en el Capítulo 2, se recomienda al lector que utilice la documentación de OpenGL para obtener los detalles necesarios.

2 VARIABLES UNIFORMES
Renderizar una escena para que parezca 3D requiere construir matrices de transformación apropiadas, como las descritas en el Capítulo 3, y aplicarlas a cada uno de los vértices de los modelos. Es más eficiente aplicar las operaciones de matriz requeridas en el sombreador de vértices, y es habitual enviar estas matrices desde la aplicación C ++ / OpenGL al sombreador en una variable uniforme. Las variables uniformes se declaran en un sombreador utilizando la palabra clave "uniform". El siguiente ejemplo, que declara variables para contener matrices de proyección y vista de modelo, será adecuado para nuestro programa de cubo:
La palabra clave "mat4" indica que se trata de matrices 4x4. Aquí hemos nombrado la variable mv_matrix para contener la matriz de vista de modelo y la variable proj_matrix para contener la matriz de proyección. Dado que las transformaciones 3D son 4x4, mat4 es un tipo de datos comúnmente utilizado en uniformes de sombreado GLSL.
El envío de datos desde una aplicación C ++ / OpenGL a una variable uniforme requiere los siguientes pasos: (a) adquirir una referencia a la variable uniforme y (b) asociar un puntero a los valores deseados con la referencia uniforme adquirida. Suponiendo que el programa de renderizado vinculado se guarda en una variable llamada "renderingProgram", las siguientes líneas de código especificarían que enviaremos matrices de vista de modelo y proyección a los dos uniformes mv_matrix y proj_matrix en nuestro ejemplo de cubo:

El ejemplo anterior asume que hemos utilizado las utilidades GLM para construir la vista de modelo y la matriz de proyección transforma mvMat y pMat, como se discutirá con mayor detalle en breve. Son del tipo mat4 (una clase GLM). La llamada a la función GLM value_ptr () devuelve una referencia a los datos de la matriz, que glUniformMatrix4fv () necesita para transferir esos valores de la matriz a la variable uniforme. 