NUESTRO PRIMER PROGRAMA 3D: UN CUBO 3D
¡Es hora de juntar todas las piezas! Para construir un sistema C ++ / OpenGL / GLSL completo para renderizar nuestro cubo en un “mundo” 3D, todos los mecanismos descritos hasta ahora deberán estar juntos y perfectamente coordinados. Podemos reutilizar parte del código que vimos anteriormente en el Capítulo 2. Específicamente, no repetiremos las siguientes funciones para leer archivos que contienen código de sombreado, compilarlos y vincularlos y detectar errores GLSL; de hecho, recuerde que los hemos movido a un archivo “Utils.cpp”:

También necesitaremos una función de utilidad que construya una matriz de perspectiva, dado un ángulo de campo de visión específico para el eje Y, la relación de aspecto de la pantalla y los planos de recorte cercanos y lejanos deseados (seleccionando valores apropiados para planos de recorte cercanos y lejanos se discute en la Sección 4.9). Si bien podríamos escribir fácilmente una función de este tipo nosotros mismos, GLM ya incluye una:
glm :: perspectiva (<campo de visión>, <relación de aspecto>, <plano cercano>, <plano lejano>);

Ahora construimos el programa completo de cubos 3D, que se muestra a continuación en el Programa 4.1

Echemos un vistazo de cerca al código del Programa 4.1. Es importante que entendamos cómo funcionan todas las piezas y cómo funcionan juntas.
Comience examinando la función setupVertices (), llamada por init (). Al comienzo de esta función, se declara una matriz llamada vertexPositions que contiene los 36 vértices que componen el cubo. Al principio, podría preguntarse por qué este cubo tiene 36 vértices,
cuando lógicamente un cubo solo debería requerir ocho. La respuesta es que necesitamos construir nuestro cubo con triángulos, por lo que cada una de las seis caras del cubo debe estar formada por dos triángulos, para un total de 6x2 = 12 triángulos (ver Figura 4.4). Dado que cada triángulo está especificado por tres vértices, esto totaliza 36 vértices.
Dado que cada vértice tiene tres valores (x, y, z), hay un total de 36x3 = 108 valores en la matriz. Es cierto que cada vértice participa en múltiples triángulos, pero aún especificamos cada vértice por separado porque por ahora estamos enviando los vértices de cada triángulo por la tubería por separado.
El cubo se define en su propio sistema de coordenadas, con (0,0,0) en su centro y con sus esquinas que van de -1,0 a +1,0 a lo largo de los ejes x, y, z. El resto de la función "configura el VAO y dos VBO (aunque solo se usa uno) y carga los vértices del cubo en el búfer 0 de VBO

Tenga en cuenta que la función init () realiza tareas que solo deben realizarse una vez: leer en el código del sombreador y construir el programa de renderizado, y cargar los vértices del cubo en el VBO (llamando a setupVertices ()). Tenga en cuenta que también posiciona el cubo y la cámara en el mundo. Más tarde animaremos el cubo y también veremos cómo mover la cámara, momento en el que es posible que necesitemos eliminar esta posición codificada.

Ahora veamos la función display (). Recuerde que se puede llamar a display () repetidamente y la velocidad a la que se llama se denomina velocidad de fotogramas. Es decir, la animación funciona dibujando y volviendo a dibujar continuamente la escena, o fotograma, muy rápidamente. Por lo general, es necesario borrar el búfer de profundidad antes de renderizar un marco para que la eliminación de la superficie oculta se produzca correctamente (si no se borra el búfer de profundidad, a veces se pueden eliminar todas las superficies, lo que da como resultado una pantalla completamente negra). De forma predeterminada, los valores de profundidad en OpenGL oscilan entre 0,0 y 1,0. La limpieza del búfer de profundidad se realiza llamando a glClear (GL_DEPTH_BUFFER_BIT), que llena el búfer de profundidad con el valor predeterminado (generalmente 1.0)

A continuación, display () habilita los sombreadores llamando a glUseProgram (), instalando el código GLSL en la GPU. Recuerde que esto no ejecuta el programa de sombreado, pero habilita las siguientes llamadas OpenGL para determinar el atributo de vértice del sombreador y las ubicaciones uniformes. A continuación, la función display () obtiene las ubicaciones de las variables uniformes, construye las matrices de perspectiva, vista y modelo3, concatena las matrices de vista y modelo en una única matriz de MV y asigna las matrices de perspectiva y MV a sus uniformes correspondientes. Aquí, vale la pena señalar también la forma de la llamada GLM a la función translate ():
vMat = glm :: translate (glm :: mat4 (1.0f), glm :: vec3 (-cameraX, -cameraY, -cameraZ));
La llamada de apariencia algo críptica construye una matriz de traducción (a) comenzando con una matriz de identidad (usando el constructor glm :: mat4 (1.0f)) y (b) especificando valores de traducción en forma de vector (con glm: : constructor vec3 (x, y, z)).
Muchas de las operaciones de transformación GLM utilizan este enfoque

3 Un lector astuto puede notar que no debería ser necesario construir la matriz de perspectiva cada vez que se llama a display (), porque su valor no cambia. Esto es parcialmente cierto: sería necesario volver a calcular la matriz de perspectiva si el usuario cambiara el tamaño de la ventana mientras se ejecutaba el programa. En la Sección 4.11 manejaremos esta situación de manera más eficiente y, en el proceso, trasladaremos el cálculo de la matriz de perspectiva de display () a la función init () 